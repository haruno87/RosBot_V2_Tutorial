# 技术路线     三维建图 - 三维定位 - 二维导航



## 1. 寻找主要的 launch 文件

以 `快速运行指令` 中的指令入手

```
roslaunch nav point_loc.launch
```

其中 roslaunch 启动的是一个名为 nav 的功能包下面名叫 point_loc.launch 的文件，我们此时的路径是 `~/max_ws` ，所以我们去 max_ws 下的 src(一般的代码都是放在 src)中找到 nav ，然后在 launch 目录下找到 point_loc.launch 这个文件：

```
<launch>
    <include file="$(find unitree_lidar_ros)/launch/run_without_rviz.launch" />
    <include file="$(find point_lio_unilidar)/launch/mapping_unilidar_l2.launch" />

    <node name="localisation" pkg="service" type="localisation.py" output="screen">
        </node>

    <node pkg="service" type="transform_fusion.py" name="transform_fusion" output="screen" />


    <node pkg="pcl_ros" type="pcd_to_pointcloud" name="map_publisher" output="screen"
        args="/home/orangepi/max_ws/src/point_lio_unilidar/PCD/scans_0807.pcd 5 _frame_id:=map cloud_pcd:=map" />


	<node name = "map_server" pkg = "map_server" type = "map_server" args="$(find nav)/map/nav0807.yaml /map:=prior_map"/>


    <include file="$(find nav)/launch/pointcloud2laserscan.launch" />

    <!-- <node name = "Trans_TF_2d" pkg = "service" type = "Trans_TF_2d"/> -->




    <node pkg="tf2_ros" type="static_transform_publisher" name="tf_pub_1" args="-0.10 0 0 0 0 0 aft_mapped aft_mapped_body" />
	<!-- 发布一个雷达初始位置camera_init到机器人足端初始位置body_init的静态映射 -->
	<node pkg="tf2_ros" type="static_transform_publisher" name="tf_pub_2" args="0.10 0 0 0 0 0 camera_init robot_foot_init" />
    <!-- <node pkg="service" type="publish_initial_pose.py" name="publish_initial_pose" output="screen" /> -->

    <include file="$(find nav)/launch/move_base_TEB.launch" />

     <node pkg="jie_ware" type="costmap_cleaner" name="costmap_cleaner" />
    <node name="motor_control" pkg="service" type="motor_control.py" output="screen"/>


    <node name="move_point" pkg="service" type="move_point.py" output="screen">
    </node>
</launch>
```

分析这份 launch 文件：
其中 `<include file="$(find unitree_lidar_ros)/launch/run_without_rviz.launch" />` 这种 `include file` 的文件也是一个 launch 文件，可以跳转到对应文件继续分析。

而 `<nodename="move_point"pkg="service"type="move_point.py"output="screen" `

对应的就是一个小节点，可以跳转到对应文件查看具体实现。

## 2.分析launch文件

`<includefile="$(find unitree_lidar_ros)/launch/run_without_rviz.launch"/>`

`<includefile="$(find point_lio_unilidar)/launch/mapping_unilidar_l2.launch"/>`

这两个节点启动的分别是 3d 雷达的运行节点已经 Point_lio 的 SLAM 节点，（SLAM 全称是 simultaneous localization and mapping同时定位与映射，可以简单理解为建图加定位）。

`<nodename="localisation"pkg="service"type="localisation.py"output="screen">`

`</node>`

`<nodepkg="service"type="transform_fusion.py"name="transform_fusion"output="screen"/>`

这两个文件分别是定位节点（将建好的静态 3d 地图与雷达扫描到的特征信息进行匹配)以及坐标系转换节点（建立转换坐标 map 到机器人基坐标系 aft_mapped的 2d 转换，这是由于 3d 雷达多了很多维度的信息，只需要提取部分）。

```
<node pkg="pcl_ros" type="pcd_to_pointcloud" name="map_publisher" output="screen"
        args="/home/orangepi/max_ws/src/point_lio_unilidar/PCD/scans_0807.pcd 5 _frame_id:=map cloud_pcd:=map" />

```

这个节点的作用是发布静态的 3d 地图供前面两个节点定位以及坐标变换使用，可以根据 args 中的路径找到对应的地图，后续有新建的地图可以直接更改名字替换掉。

```
<node name = "map_server" pkg = "map_server" type = "map_server" args="$(find nav)/map/nav0807.yaml /map:=prior_map"/>

```

这个节点的作用是发布 map 的 tf 坐标变换，读到这里可能会有疑惑，为什么要发布两个 map？

这是由于 `pcl_ros`这个节点发布的 map 是一个话题和坐标用于 三维空间的定位与 tf 转换，而导航 move_base需要的是二维栅格地图，这就需要 `map_server` 发布栅格地图的话题，但是由于/map 这个话题被占用了，所以发布到 `prior_map` 这个话题上，需要注意的是这两个节点的坐标系 frame 是一样的。

```
<include file="$(find nav)/launch/pointcloud2laserscan.launch" />

```

这个节点的作用是将 3d 雷达的点云由 3d 转为 2d 用于导航使用。

```
	<node pkg="tf2_ros" type="static_transform_publisher" name="tf_pub_2" args="0.10 0 0 0 0 0 camera_init robot_foot_init" />
    <node pkg="tf2_ros" type="static_transform_publisher" name="tf_pub_1" args="-0.10 0 0 0 0 0 aft_mapped aft_mapped_body" />

```

这两个指令是发布坐标变换的，将三维空间下的机器人坐标转换为二维平面，但是实测下来效果并没有更好。

这里补充机器人运动的坐标系变换：
map - > odom - > base_link 即 map - > 里程计 - > 基坐标。这里我的三维里程计是 camera_init，三维基坐标系是 aft_mapped。

```
<include file="$(find nav)/launch/move_base_TEB.launch" />

```

上面这条指令非常重要，是二维导航的关键,`src/nav/param` 中看到配置文件，其中有与地图相关的文件（带有 costmap 的）以及与运动性能相关的文件（teb_local_planner_params.yaml），其中需要特别注意的是 `global_costmap_params `和 `local_costmap_params` 中的 `global_frame` 和 `robot_base_frame` 。可以根据上面谈到的坐标系变换理解一下。其中 local_costmap中的 global_frame 官方建议是填写里程计坐标系，但是实测下来 map 更加稳定。

```
nodepkg="jie_ware"type="costmap_cleaner"name="costmap_cleaner"
```

上面这条指令是用于手动调整机器人位姿时清除一次地图中残留的代价地图。

```
    <node name="motor_control" pkg="service" type="motor_control.py" output="screen"/>

```

这条指令是电机控制节点的指令，如果使用 2d 雷达，这个节点也会自动订阅 imu 的话题进行融合，3d 只需要打开这个节点就好。需要注意的是，service 功能包下还有键盘控制的节点，当需要遥控建图或进行运动测试时可以启用 `rosrun service key_scans.py `，使用键盘的 wasd 可以进行控制，按下 q 就退出节点。

```
<node name="move_point" pkg="service" type="move_point.py" output="screen">
    </node>
```

最后这个节点是用来订阅语音模型发来的信息，例如我们使用指令控制机器人带领我们去饮水机附近，就是通过`src/baidu_model_chat_linux_0812/functions.py` 中 function calling 发布的`/voice_keyword`话题（发布信息的格式为`{"keyword": "go to point a"}`）


## 3. 怎么切换 2d 或者 3d 雷达？

现在使用的是 3d 雷达，启动的文件是 `roslaunch nav point_loc.launch` 文件。使用 2d 雷达的话，首先需要把 `src/nav/param`进行重命名，然后把`src/nav/param_rplidar` 重命名为 `src/nav/param`，再把`src/nav/launch/move_base_rplidar.launch`重命名为`src/nav/launch/move_base.launch`，最后启动 `roslaunch nav start.launch`。

## 4. 外设参考文档：

`https://github.com/unitreerobotics/point_lio_unilidar` Point_lio 三维 SLAM

`https://github.com/unitreerobotics/unilidar_sdk2`宇树 L2 雷达

`https://www.yahboom.com/study/IMU` IMU模块 密码`dj32`

`https://www.yahboom.com/study/RPLIDAR_SLAMTEC`  二维激光雷达 密码 `32fm`  ***这里也有很丰富的 ros 课程资料

`https://github.com/66Lau/NEXTE_Sentry_Nav?tab=readme-ov-file ` 非常重要的路径参考
